{"title":"Análisis exploratorio de los datos","markdown":{"yaml":{"title":"Análisis exploratorio de los datos"},"headingText":"Importar librerías","containsRefs":false,"markdown":"\n\n\nEn esta sección, se importan las librerías necesarias para el análisis exploratorio de los datos de las acciones de Bitcoin. Se utilizarán herramientas como Pandas y Numpy para el manejo de los datos, Plotly para la visualización, y algunos módulos de statsmodels para el análisis de series de tiempo y pruebas estadísticas.\n\n```{python}\nimport pandas as pd\nimport numpy as np\n\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\n\nfrom sklearn.impute import KNNImputer\n\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nfrom statsmodels.graphics.tsaplots import plot_acf\nfrom statsmodels.tsa.stattools import acf, adfuller\nfrom statsmodels.stats.diagnostic import acorr_ljungbox\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n```\n\n# Importar datos\n\nA continuación, se realiza la importación de los datos históricos de Bitcoin desde una fuente externa. Estos datos contienen información relevante sobre las acciones, que se utilizará en el análisis para identificar tendencias, patrones y comportamiento de la serie temporal.\n\n``` {python}\nbtc = pd.read_csv('https://raw.githubusercontent.com/lihkir/Data/refs/heads/main/Bitcoin%20Historical%20Data.csv')\n\nbtc.head()\n```\n\n# Exploración de los datos\n\nEn esta sección, se observa la forma general del DataFrame para conocer el número de registros y columnas.\n\n``` {python}\nbtc.shape\n```\n\nDescripción inicial del DataFrame, mostrando las columnas, tipos de datos y valores nulos presentes:\n\n``` {python}\nbtc.info()\n```\n\nPara realizar el análisis, es necesario convertir las columnas numéricas de tipo string a float y la columna Date a un formato de fecha. A continuación, se aplica la conversión de datos y se ajusta el formato de los volúmenes.\n\n``` {python}\nbtc[['Price', 'Open', 'High', 'Low']] = btc[['Price', 'Open', 'High', 'Low']].replace(',', '', regex=True).astype(float)\nbtc['Change %'] = btc['Change %'].str.replace('%', '').astype(float)\n\nbtc['Date'] = pd.to_datetime(btc['Date'], format='%m/%d/%Y')\n\ndef convert_volume(vol):\n    if isinstance(vol, str):\n        if 'K' in vol:\n            return float(vol.replace('K', '').replace(',', '')) * 1_000\n        elif 'M' in vol:\n            return float(vol.replace('M', '').replace(',', '')) * 1_000_000\n        elif 'B' in vol:\n            return float(vol.replace('B', '').replace(',', '')) * 1_000_000_000\n        else:\n            return float(vol.replace(',', ''))\n    else:\n        return vol\n\nbtc['Vol.'] = btc['Vol.'].apply(convert_volume)\n\nbtc.head()\n```\n\nLuego de las conversiones, se revisa la estructura actual del DataFrame para confirmar que los tipos de datos sean correctos y que se hayan eliminado los símbolos y comas.\n\n``` {python}\nbtc = btc.sort_values(by='Date')\nbtc = btc.reset_index(drop = True)\n\nbtc.info()\n```\n\n``` {python}\nbtc.describe()\n```\n\nEl resumen estadístico revela que el precio promedio de Bitcoin ha sido de aproximadamente 10,812.28 dólares, con un precio de apertura promedio cercano de 10,798.90 dólares. A lo largo del tiempo, los precios diarios más altos han promediado 11,067.45 dólares, mientras que los precios más bajos se han situado en 10,511.89 dólares, indicando una volatilidad diaria moderada. El volumen promedio de transacciones ha sido de 12.38 millones, mostrando un mercado activo, aunque con periodos de bajo volumen mínimo de 80 unidades. El cambio porcentual promedio ha sido positivo, de 0.42% por día, pero con episodios de alta volatilidad que incluyen caídas de hasta -57.21%. Además, los precios han sido significativamente bajos en el primer cuartil, con un valor de 226.70 dólares, lo que indica que durante un cuarto del tiempo analizado, el precio de Bitcoin se mantuvo muy por debajo de los niveles actuales.\n\n# Datos faltantes\n\nEl análisis de los datos faltantes en el conjunto de datos de Bitcoin muestra que la columna Volumen presenta valores nulos, que representan un pequeño porcentaje del total de registros. Para manejar estos datos faltantes, se ha implementado una imputación utilizando el algoritmo KNNImputer con 5 vecinos. Este enfoque permite estimar los valores faltantes en función de los patrones observados en los datos circundantes, lo cual es efectivo para mantener la coherencia y calidad de la información antes de proceder con el análisis de series de tiempo.\n\n``` {python}\nmissing_values = btc.isnull().sum()\nmissing_percentage = round((missing_values / len(btc)) * 100, 4)\nmissing_percentage\n```\n\nLa columna `Vol.` presenta un 0.12% de datos faltantes, lo cual es un porcentaje bajo pero significativo para los análisis.\n\nPara completar los valores faltantes en la columna de Volumen, se emplea el algoritmo de imputación KNNImputer, que utiliza la información de los vecinos más cercanos para predecir los valores faltantes.\n\n``` {python}\nimputer = KNNImputer(n_neighbors = 5)\n\nbtc[['Vol.']] = imputer.fit_transform(btc[['Vol.']])\n\nbtc.head()\n```\n\n# Visualización de precio y volumen tradeado\n\n``` {python}\n#| output: false\nfig = go.Figure(\n    data = [\n        go.Candlestick(\n            x = btc['Date'],\n            open = btc['Open'],\n            high = btc['High'],\n            low = btc['Low'],\n            close = btc['Price'],\n            name = 'Precio Bitcoin'\n        )\n    ]\n)\n\nfig.update_layout(\n    title='Gráfico de Velas de Bitcoin',\n    xaxis_title='Fecha',\n    yaxis_title='Precio (USD)',\n    hovermode='x',\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 40},\n    xaxis={'gridcolor': '#222', 'tickfont': {'color': 'white'}},\n    yaxis={'gridcolor': '#222', 'tickfont': {'color': 'white'}},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis_rangeslider_visible=False,\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/candlestick_price.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/candlestick_price.html'\n    width = '730'\n    height = '400'\n    title = 'Candlestick de la serie de tiempo del precio'\n>\n</iframe>\n```\n\nEn el gráfico de velas del Bitcoin se puede observar la evolución del precio de esta criptomoneda a lo largo del tiempo, abarcando desde sus primeros días hasta el año 2024. El gráfico revela períodos de alta volatilidad, con importantes picos en los años 2017-2018 y 2020-2022, en los cuales se registraron máximos históricos seguidos de caídas rápidas. Estos movimientos bruscos sugieren una naturaleza especulativa y altamente volátil en el mercado de Bitcoin. En el periodo más reciente (2023-2024), se evidencia un nuevo máximo cercano a los 70,000 USD, acompañado de correcciones pronunciadas, lo que indica una posible consolidación con fluctuaciones significativas. \n\n``` {python}\n#| output: false\nfig = go.Figure()\n\nfig.add_trace(\n    go.Histogram(\n        x = btc['Date'],\n        y = btc['Vol.'],\n        name = 'Volumen',\n        histfunc = 'sum'\n    )\n)\n\nfig.update_layout(\n    title='Histograma de Volumen Tradeado Diario',\n    xaxis_title='Fecha',\n    yaxis_title='Volumen tradeado',\n    bargap=0.1,\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 40},\n    xaxis={'gridcolor': '#222', 'tickfont': {'color': 'white'}},\n    yaxis={'gridcolor': '#222', 'tickfont': {'color': 'white'}},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/histogram_vol.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/histogram_vol.html'\n    width = '730'\n    height = '400'\n    title = 'Histograma del volumen de tradeado'\n>\n</iframe>\n```\n\nEn el histograma del volumen tradeado diario de Bitcoin se puede observar un patrón particular en la actividad de trading a lo largo del tiempo. La gráfica muestra un aumento abrupto y masivo del volumen tradeado en un periodo específico, alrededor del año 2022. Esto sugiere que durante este período hubo un incremento significativo en la cantidad de Bitcoin intercambiado, superando los 60 mil millones de unidades. Antes de este aumento, el volumen diario se mantuvo relativamente bajo y estable, lo que indica que la mayoría de la actividad de trading se concentró en los años más recientes. Este comportamiento puede estar relacionado con un mayor interés de inversores, la adopción generalizada de Bitcoin o la participación de grandes actores del mercado, provocando así picos de actividad inusuales. La presencia de este único pico elevado en la gráfica sugiere un cambio estructural en el mercado, lo cual es crucial para tener en cuenta en los análisis posteriores y en la modelización de la serie temporal.\n\n# Visualización semanal, mensual y anual del precio del bitcoin\n\n``` {python}\nbtc_c = btc.copy()\nbtc_c.set_index('Date', inplace = True)\n\nweekly_btc = btc_c.resample('W').mean()\nmonthly_btc = btc_c.resample('M').mean()\nyearly_btc = btc_c.resample('Y').mean()\n```\n\n``` {python}\n#| output: false\nfig_ts = make_subplots(\n    rows=3, cols=1, \n    shared_xaxes=True, \n    subplot_titles=(\n        'Precio Promedio Semanal',\n        'Precio Promedio Mensual',\n        'Precio Promedio Anual'\n    )\n)\n\nfig_ts.add_trace(\n    go.Scatter(\n        x=weekly_btc.index, \n        y=weekly_btc['Price'], \n        mode='lines+markers', \n        name='Precio Semanal'\n    ), \n    row=1, col=1\n)\n\nfig_ts.add_trace(\n    go.Scatter(\n        x=monthly_btc.index, \n        y=monthly_btc['Price'], \n        mode='lines+markers', \n        name='Precio Mensual'\n    ), \n    row=2, col=1\n)\n\nfig_ts.add_trace(\n    go.Scatter(\n        x=yearly_btc.index, \n        y=yearly_btc['Price'], \n        mode='lines+markers', \n        name='Precio Anual'\n    ), \n    row=3, col=1\n)\n\nfig_ts.update_layout(\n    title='Series de Tiempo Agrupadas (Semana, Mes, Año)',\n    xaxis_title='Fecha',\n    yaxis_title='Precio (USD)',\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    hovermode = 'x unified',\n    showlegend = False\n)\n\nfig_ts.show()\n```\n\n``` {python}\n#| echo: false\nfig_ts.write_html('graphs/ts_variety.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/ts_variety.html'\n    width = '700'\n    height = '800'\n    title = 'Series de Tiempo Agrupadas (Semana, Mes, Año)'\n>\n</iframe>\n```\n\nEn las series de tiempo agrupadas por semana, mes y año, se observa la evolución del precio promedio de Bitcoin con diferentes niveles de agregación. El gráfico semanal revela fluctuaciones cortas y alta volatilidad, mientras que el mensual suaviza estos movimientos, destacando picos en 2017-2018 y 2020-2022, reflejando ciclos de auge y caída. Por último, el gráfico anual muestra un crecimiento sostenido desde 2017, con un notable aumento en 2021 y una estabilización posterior hasta un nuevo máximo en 2024. Esta combinación permite analizar tanto la volatilidad a corto plazo como las tendencias a largo plazo.\n\n``` {python}\nbtc_c['Week'] = btc_c.index.to_series().dt.isocalendar().week\nbtc_c['Month'] = btc_c.index.to_series().dt.month\nbtc_c['Year'] = btc_c.index.to_series().dt.year\n```\n\n``` {python}\n#| output: false\ndef get_box(df: pd.DataFrame, X: str, Y: str, TITLE: str):\n    fig = px.box(\n        df,\n        x = X,\n        y = Y,\n        title = TITLE\n    )\n\n    fig.update_layout(\n        margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n        plot_bgcolor='rgba(0, 0, 0, 0.0)',\n        paper_bgcolor='rgba(0, 0, 0, 0.0)',\n        font_color=\"white\",\n        hoverlabel=dict(\n            bgcolor=\"#222\"\n        ),\n        xaxis=dict(gridcolor='#222', tickfont=dict(color='white'), title = 'Semana'),\n        yaxis=dict(gridcolor='#222', tickfont=dict(color='white'), title = 'Precio')\n    )\n\n    return fig\n\nfig_box_w = get_box(btc_c, 'Week', 'Price', 'Distribución semanal')\nfig_box_m = get_box(btc_c, 'Month', 'Price', 'Distribución mensual')\nfig_box_y = get_box(btc_c, 'Year', 'Price', 'Distribución anual')\n\nfig_box_w.show()\nfig_box_m.show()\nfig_box_y.show()\n```\n\n``` {python}\n#| echo: false\nfig_box_w.write_html('graphs/box_variety_w.html')\nfig_box_m.write_html('graphs/box_variety_m.html')\nfig_box_y.write_html('graphs/box_variety_y.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/box_variety_w.html'\n    width = '730'\n    height = '400'\n    title = 'Series de Tiempo Agrupadas (Semana, Mes, Año)'\n>\n</iframe>\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/box_variety_m.html'\n    width = '730'\n    height = '400'\n    title = 'Series de Tiempo Agrupadas (Semana, Mes, Año)'\n>\n</iframe>\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/box_variety_y.html'\n    width = '730'\n    height = '400'\n    title = 'Series de Tiempo Agrupadas (Semana, Mes, Año)'\n>\n</iframe>\n```\n\nEn los gráficos de distribución semanal, mensual y anual del precio de Bitcoin, se observa la variabilidad y dispersión del precio en diferentes escalas de tiempo. En la distribución semanal, los boxplots reflejan una amplia variabilidad, con picos notables en algunas semanas donde el precio superó los 60,000 USD, lo que sugiere fluctuaciones significativas en cortos periodos. En la distribución mensual, los rangos son más amplios, y se observan outliers frecuentes que destacan eventos extremos en cada mes, especialmente en los primeros y últimos meses del año. Por último, la distribución anual muestra una tendencia de expansión del rango de precios a medida que avanza el tiempo, con un crecimiento constante y variabilidad creciente desde 2016, alcanzando picos de precio más elevados en 2021 y 2024.\n\n# Validación de estacionariedad de la serie de tiempo\n\n``` {python}\n#| output: false\nlag_acf = acf(btc_c['Price'], nlags=2000)\n\nfig = go.Figure()\n\nfig.add_trace(go.Bar(\n    x=list(range(len(lag_acf))),\n    y=lag_acf,\n    marker_color='blue'\n))\n\nfig.update_layout(\n    title='Autocorrelación',\n    xaxis_title='Lags',\n    yaxis_title='Autocorrelación',\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis=dict(gridcolor='#222', tickfont=dict(color='white'))\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/acf_1.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/acf_1.html'\n    width = '730'\n    height = '400'\n    title = 'ACF de las diferencias estacionales'\n>\n</iframe>\n```\n\nEn el gráfico de autocorrelación, se representa la correlación de la serie temporal del precio de Bitcoin consigo misma en diferentes retardos (lags). La autocorrelación inicial es cercana a 1, lo cual indica que los valores consecutivos del precio están altamente correlacionados, es decir, existe una fuerte dependencia entre observaciones adyacentes. A medida que aumenta el número de retardos, la autocorrelación disminuye gradualmente hasta acercarse a cero, lo que sugiere que las observaciones distantes en el tiempo tienen poca o ninguna relación entre sí.\n\nEsta tendencia de decaimiento lento es una señal de que la serie no es estacionaria, ya que la autocorrelación no converge rápidamente hacia cero. La no estacionariedad implica que hay patrones como tendencias o ciclos que persisten en el tiempo, lo cual es importante tener en cuenta para modelar adecuadamente esta serie y elegir métodos de transformación que permitan hacerla estacionaria para aplicar modelos que asumen esta propiedad.\n\n## Prueba de estacionariedad de Ljung-Box\n\n``` {python}\nresult = acorr_ljungbox(btc_c['Price'], lags=[200, 500, 1000, 2000], return_df=True)\n\nif (result['lb_pvalue'] < 0.05).any():\n    print(\"La serie no es estacionaria (rechazamos la hipótesis nula para algunos lags).\")\nelse:\n    print(\"La serie es estacionaria (no se rechaza la hipótesis nula para los lags evaluados).\")\n\nresult\n```\n\n## Prueba de estacionariedad de Dickey Fuller\n\n``` {python}\nresult = adfuller(btc_c['Price'])\n\nprint(f'Estadístico de prueba: {result[0]}')\nprint(f'Valor p: {result[1]}\\n')\n\nif result[1] < 0.05:\n    print(\"La serie es estacionaria (rechazamos la hipótesis nula).\")\nelse:\n    print(\"La serie no es estacionaria (no se rechaza la hipótesis nula).\")\n```\n\n## Transformaciones para obtener una serie estacionaria\n\nPara obtener una serie estacionaria y facilitar el análisis y modelado de los precios de Bitcoin, se procederá a realizar una transformación basada en la diferenciación. La serie original ha mostrado indicios de no ser estacionaria, con un decaimiento lento en la autocorrelación, lo cual sugiere la presencia de tendencia. Por esta razón, se aplicará la diferenciación, que consiste en restar a cada valor su valor previo, con el objetivo de eliminar tendencias y estabilizar la media de la serie. Posteriormente, se evaluará la estacionariedad de la serie diferenciada mediante la prueba de Dickey-Fuller Aumentada (ADF), observando si el valor p es menor a 0.05, lo que indicaría que la serie ya es estacionaria.\n\n``` {python}\nbtc_d = btc_c.copy()\nbtc_d['Price'] = btc_c['Price'].diff()\n\nbtc_d\n```\n\n``` {python}\nresult_diff = adfuller(btc_d['Price'].dropna())\nprint(f'Estadístico de prueba: {result_diff[0]}')\nprint(f'Valor p: {result_diff[1]}\\n')\n\nif result_diff[1] < 0.05:\n    print(\"La serie diferenciada es estacionaria (rechazamos la hipótesis nula).\")\nelse:\n    print(\"La serie diferenciada no es estacionaria (no se rechaza la hipótesis nula).\")\n```\n\n# Comportamiento por agrupaciones de la serie de tiempo\n\nPara explorar más a fondo el comportamiento de la serie diferenciada, se realizará un análisis por períodos, agrupando los datos a nivel diario, semanal y mensual para calcular la media y la desviación estándar de los precios en cada intervalo. Esto permitirá identificar patrones de variabilidad en diferentes escalas temporales. También se calcularán medias y desviaciones estándar móviles para ventanas de 7, 30 y 90 días, lo que ayudará a observar cómo evolucionan el promedio y la dispersión de los precios a lo largo del tiempo.\n\n``` {python}\nweekly = btc_d['Price'].resample('W').agg(['mean', 'std'])\ndaily = btc_d['Price'].resample('D').agg(['mean', 'std'])\nmonthly = btc_d['Price'].resample('M').agg(['mean', 'std'])\n```\n\n``` {python}\nbtc_d['mu_7'] = btc_d['Price'].rolling(window = 7).mean()\nbtc_d['std_7'] = btc_d['Price'].rolling(window = 7).std()\n\nbtc_d['mu_30'] = btc_d['Price'].rolling(window = 30).mean()\nbtc_d['std_30'] = btc_d['Price'].rolling(window = 30).std()\n\nbtc_d['mu_90'] = btc_d['Price'].rolling(window = 90).mean()\nbtc_d['std_90'] = btc_d['Price'].rolling(window = 90).std()\n\nbtc_d\n```\n\n``` {python}\n#| output: false\ndef get_hist(df: pd.DataFrame, diff_: int, title: str):\n    fig = px.histogram(\n        df['Price'].diff(diff_).dropna(),\n        nbins = 30,\n        title = title\n    )\n\n    fig.update_layout(\n        margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n        plot_bgcolor='rgba(0, 0, 0, 0.0)',\n        paper_bgcolor='rgba(0, 0, 0, 0.0)',\n        font_color=\"white\",\n        hoverlabel=dict(\n            bgcolor=\"#222\"\n        ),\n        xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n        yaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n        showlegend = False\n    )\n\n    return fig\n\nfig_7 = get_hist(btc_d, 7, 'Distribución con lag = 7')\nfig_30 = get_hist(btc_d, 30, 'Distribución con lag = 30')\nfig_90 = get_hist(btc_d, 90, 'Distribución con lag = 90')\n\nfig_7.show()\nfig_30.show()\nfig_90.show()\n```\n\n``` {python}\n#| echo: false\nfig_7.write_html('graphs/hist_7.html')\nfig_30.write_html('graphs/hist_30.html')\nfig_90.write_html('graphs/hist_90.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/hist_7.html'\n    width = '730'\n    height = '400'\n    title = 'Distribución con lag = 7'\n>\n</iframe>\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/hist_30.html'\n    width = '730'\n    height = '400'\n    title = 'Distribución con lag = 30'\n>\n</iframe>\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/hist_90.html'\n    width = '730'\n    height = '400'\n    title = 'Distribución con lag = 90'\n>\n</iframe>\n```\n\nEn los histogramas de las distribuciones con diferentes retardos (lags) de 7, 30 y 90 días, se puede observar la variabilidad de los precios diferenciados del Bitcoin a lo largo del tiempo. En los tres gráficos, se nota una clara concentración de los valores alrededor de cero, indicando que la mayoría de las diferencias en los precios son relativamente pequeñas en cada lag evaluado.\n\nSin embargo, a medida que aumenta el lag de 7 a 30 y luego a 90 días, se aprecia un aumento gradual en la dispersión de los datos, lo cual se refleja en colas más extendidas en los histogramas. Este comportamiento indica que, conforme se incrementa el período de comparación, las diferencias de precio tienden a ser más amplias, sugiriendo una mayor variabilidad en el largo plazo.\n\n# Medias móviles y tendencia\n\n``` {python}\n#| output: false\nbtc_d = btc_d.fillna(0)\n\nMA2 = btc_d['Price'].rolling(window = 2).mean()\nTwoXMA2 = MA2.rolling(window=2).mean()\n\nMA4 = btc_d['Price'].rolling(window = 4).mean()\nTwoXMA4 = MA4.rolling(window=2).mean()\n\nMA3 = btc_d['Price'].rolling(window = 3).mean()\nThreeXMA3 = MA3.rolling(window=3).mean()\n\nfig = make_subplots(\n    rows=3, cols=1, \n    shared_xaxes=True, \n    subplot_titles=(\"2 day MA & 2X2 day MA\", \"4 day MA & 2X4 day MA\", \"3 day MA & 3X3 day MA\")\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=btc_d['Price'].iloc[:45], \n        mode='lines', \n        name='Close Price', \n        line=dict(color='#9B7EBD')\n    ), \n    row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=MA2.iloc[:45], \n        mode='lines', \n        name='2 day MA', \n        line=dict(color='#7AB2D3', dash='dash')\n    ), \n    row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=TwoXMA2.iloc[:45], \n        mode='lines', \n        name='2X2 day MA', \n        line=dict(color='#CBD2A4', dash='dash')\n    ), \n    row=1, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=btc_d['Price'].iloc[:45], \n        mode='lines', \n        name='Close Price', \n        showlegend=False, \n        line=dict(color='#9B7EBD')\n    ), \n    row=2, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=MA4.iloc[:45], \n        mode='lines', \n        name='4 day MA', \n        line=dict(color='#7AB2D3', dash='dash')\n    ), \n    row=2, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=TwoXMA4.iloc[:45], \n        mode='lines', \n        name='2X4 day MA', \n        line=dict(color='#CBD2A4', dash='dash')\n    ), \n    row=2, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=btc_d['Price'].iloc[:45], \n        mode='lines', \n        name='Close Price', \n        showlegend=False, \n        line=dict(color='#9B7EBD')\n    ), \n    row=3, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=MA3.iloc[:45], \n        mode='lines', \n        name='3 day MA', \n        line=dict(color='#7AB2D3', dash='dash')\n    ), \n    row=3, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=ThreeXMA3.iloc[:45], \n        mode='lines', \n        name='3X3 day MA', \n        line=dict(color='#CBD2A4', dash='dash')\n    ), \n    row=3, col=1\n)\n\nfig.update_layout(\n    title='',\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    yaxis=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    xaxis2=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    yaxis2=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    xaxis3=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    yaxis3=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    hovermode='x unified',\n    showlegend=False\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/media_movil.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/media_movil.html'\n    width = '730'\n    height = '800'\n    title = 'Distribución con lag = 7'\n>\n</iframe>\n```\n\nLos gráficos muestran la evolución de los precios diferenciados de Bitcoin utilizando medias móviles (2, 3 y 4 días) y sus versiones suavizadas (2X y 3X). Las medias móviles siguen de cerca las fluctuaciones a corto plazo, mientras que las medias dobles suavizan las curvas, destacando tendencias más claras y menos influenciadas por variaciones bruscas. Las curvas suavizadas permiten identificar patrones subyacentes y direcciones generales, eliminando parte del ruido presente en los datos diarios. Esto facilita la visualización de la evolución de los precios en diferentes escalas temporales.\n\nLa descomposición de la serie de tiempo se realiza para identificar y separar sus componentes clave: tendencia, estacionalidad y residuales, lo que facilita el análisis y el modelado.\n\n``` {python}\n#| output: false\ndecomposition = seasonal_decompose(\n    btc_d['Price'], \n    model='additive', \n    period=180\n)\n\nfig = make_subplots(\n    rows=4, cols=1, \n    shared_xaxes=True, \n    subplot_titles=(\"Observado\", \"Tendencia\", \"Estacionalidad\", \"Residual\")\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index, \n        y=btc_d['Price'], \n        mode='lines', \n        name='Observado', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=1, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index, \n        y=decomposition.trend, \n        mode='lines', \n        name='Tendencia', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=2, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index, \n        y=decomposition.seasonal, \n        mode='lines', \n        name='Estacionalidad', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=3, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index, \n        y=decomposition.resid, \n        mode='lines', \n        name='Residual', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=4, col=1\n)\n\nfig.update_layout(\n    title_text=\"Descomposición Estacional de la Serie de Tiempo\", \n    showlegend=False,\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis4=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis4=dict(gridcolor='#222', tickfont=dict(color='white')),\n    hovermode = 'x unified',\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/descomposition.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/descomposition.html'\n    width = '730'\n    height = '800'\n    title = 'Distribución con lag = 7'\n>\n</iframe>\n```\n\nLa serie observada muestra una mayor volatilidad en los últimos años. La tendencia revela un comportamiento de largo plazo, destacando caídas y recuperaciones. La estacionalidad presenta patrones cíclicos repetitivos, indicando un componente periódico constante en la serie. Finalmente, los residuales capturan las variaciones no explicadas, mostrando un aumento de la fluctuación aleatoria en el periodo reciente. Esta separación es crucial para comprender mejor la dinámica del precio del Bitcoin.\n\nAhora, se ajusta el precio diferenciado de Bitcoin restando la media móvil doble de 4 días (TwoXMA4) para eliminar el componente de tendencia y suavizar las fluctuaciones de corto plazo. Este ajuste ayuda a centrarse en los cambios más significativos y reduce la influencia de la variabilidad corta. Al realizar esta transformación, se obtiene una serie que resalta las desviaciones del comportamiento promedio reciente, facilitando la identificación de patrones o anomalías.\n\n``` {python}\nbtc_ma = btc_d.copy()\n\nbtc_ma['Price_adj'] = btc_ma['Price'] - TwoXMA4\nbtc_ma = btc_ma.fillna(0)\n```\n\n``` {python}\n#| output: false\ndecomposition = seasonal_decompose(\n    btc_ma['Price_adj'], \n    model='additive', \n    period=180\n)\n\nfig = make_subplots(\n    rows=4, cols=1, \n    shared_xaxes=True, \n    subplot_titles=(\"Observado\", \"Tendencia\", \"Estacionalidad\", \"Residual\")\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_ma.index, \n        y=btc_ma['Price_adj'], \n        mode='lines', \n        name='Observado', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=1, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_ma.index, \n        y=decomposition.trend, \n        mode='lines', \n        name='Tendencia', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=2, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_ma.index, \n        y=decomposition.seasonal, \n        mode='lines', \n        name='Estacionalidad', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=3, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_ma.index, \n        y=decomposition.resid, \n        mode='lines', \n        name='Residual', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=4, col=1\n)\n\nfig.update_layout(\n    title_text=\"Descomposición Estacional de la Serie de Tiempo\", \n    showlegend=False,\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis4=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis4=dict(gridcolor='#222', tickfont=dict(color='white')),\n    hovermode = 'x unified',\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/descomposition_2.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/descomposition_2.html'\n    width = '730'\n    height = '800'\n    title = 'Distribución con lag = 7'\n>\n</iframe>\n```\n\nSe observa que la tendencia se ha aplanado considerablemente, lo que indica que las oscilaciones de corto plazo fueron removidas. La estacionalidad se mantiene, evidenciando ciclos recurrentes y patrones que persisten en la serie. Los residuales ahora capturan mejor las fluctuaciones no explicadas, lo cual puede indicar la presencia de variabilidad no sistemática o ruido en los datos. En conjunto, esta transformación permite aislar los patrones relevantes y eliminar las influencias de corto plazo, proporcionando una base más clara para el análisis de la serie de tiempo.\n\nAhora, verificaremos si nuestra serie de tiempo se mantiene siendo estacionaria o no.\n\n## Prueba de estacionariedad de Ljung-Box\n\n``` {python}\nresult = acorr_ljungbox(btc_ma['Price_adj'], lags=[24, 100, 200], return_df=True)\n\nif (result['lb_pvalue'] < 0.05).any():\n    print(\"La serie no es estacionaria (rechazamos la hipótesis nula para algunos lags).\")\nelse:\n    print(\"La serie es estacionaria (no se rechaza la hipótesis nula para los lags evaluados).\")\n\nresult\n```\n\n## Prueba de estacionariedad de Dickey Fuller\n\n``` {python}\nresult = adfuller(btc_ma['Price_adj'])\n\nprint(f'Estadístico de prueba: {result[0]}')\nprint(f'Valor p: {result[1]}\\n')\n\nif result[1] < 0.05:\n    print(\"La serie es estacionaria (rechazamos la hipótesis nula).\")\nelse:\n    print(\"La serie no es estacionaria (no se rechaza la hipótesis nula).\")\n```\n\n``` {python}\n#| output: false\nlag_acf = acf(btc_ma['Price_adj'], nlags=100)\n\nfig = go.Figure()\n\nfig.add_trace(go.Bar(\n    x=list(range(len(lag_acf))),\n    y=lag_acf,\n    marker_color='blue'\n))\n\nfig.update_layout(\n    title='Autocorrelación',\n    xaxis_title='Lags',\n    yaxis_title='Autocorrelación',\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis=dict(gridcolor='#222', tickfont=dict(color='white'))\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/acf_2.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/acf_2.html'\n    width = '730'\n    height = '400'\n    title = 'ACF de las diferencias estacionales'\n>\n</iframe>\n```\n\n# Retorno acumulado diario y volatilidad \n\n``` {python}\nbtc['R_j'] = (btc['Price'] - btc['Price'].shift(1)) / btc['Price'].shift(1)\nbtc['R_j'].fillna(0, inplace=True)\n\nbtc['A_t'] = btc['R_j'].cumsum()\n\ndef calc_volt(btc: pd.DataFrame, window: int):\n    return btc['R_j'].rolling(window = window).std()\n\nws = [7, 14, 21, 28]\nfor w in ws:\n    btc[f'σ_{w}'] = calc_volt(btc, w)\n\nbtc\n```\n\n``` {python}\nbtc.to_csv('data/btc_models.csv', index = False)\n```","srcMarkdownNoYaml":"\n\n# Importar librerías\n\nEn esta sección, se importan las librerías necesarias para el análisis exploratorio de los datos de las acciones de Bitcoin. Se utilizarán herramientas como Pandas y Numpy para el manejo de los datos, Plotly para la visualización, y algunos módulos de statsmodels para el análisis de series de tiempo y pruebas estadísticas.\n\n```{python}\nimport pandas as pd\nimport numpy as np\n\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\n\nfrom sklearn.impute import KNNImputer\n\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nfrom statsmodels.graphics.tsaplots import plot_acf\nfrom statsmodels.tsa.stattools import acf, adfuller\nfrom statsmodels.stats.diagnostic import acorr_ljungbox\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n```\n\n# Importar datos\n\nA continuación, se realiza la importación de los datos históricos de Bitcoin desde una fuente externa. Estos datos contienen información relevante sobre las acciones, que se utilizará en el análisis para identificar tendencias, patrones y comportamiento de la serie temporal.\n\n``` {python}\nbtc = pd.read_csv('https://raw.githubusercontent.com/lihkir/Data/refs/heads/main/Bitcoin%20Historical%20Data.csv')\n\nbtc.head()\n```\n\n# Exploración de los datos\n\nEn esta sección, se observa la forma general del DataFrame para conocer el número de registros y columnas.\n\n``` {python}\nbtc.shape\n```\n\nDescripción inicial del DataFrame, mostrando las columnas, tipos de datos y valores nulos presentes:\n\n``` {python}\nbtc.info()\n```\n\nPara realizar el análisis, es necesario convertir las columnas numéricas de tipo string a float y la columna Date a un formato de fecha. A continuación, se aplica la conversión de datos y se ajusta el formato de los volúmenes.\n\n``` {python}\nbtc[['Price', 'Open', 'High', 'Low']] = btc[['Price', 'Open', 'High', 'Low']].replace(',', '', regex=True).astype(float)\nbtc['Change %'] = btc['Change %'].str.replace('%', '').astype(float)\n\nbtc['Date'] = pd.to_datetime(btc['Date'], format='%m/%d/%Y')\n\ndef convert_volume(vol):\n    if isinstance(vol, str):\n        if 'K' in vol:\n            return float(vol.replace('K', '').replace(',', '')) * 1_000\n        elif 'M' in vol:\n            return float(vol.replace('M', '').replace(',', '')) * 1_000_000\n        elif 'B' in vol:\n            return float(vol.replace('B', '').replace(',', '')) * 1_000_000_000\n        else:\n            return float(vol.replace(',', ''))\n    else:\n        return vol\n\nbtc['Vol.'] = btc['Vol.'].apply(convert_volume)\n\nbtc.head()\n```\n\nLuego de las conversiones, se revisa la estructura actual del DataFrame para confirmar que los tipos de datos sean correctos y que se hayan eliminado los símbolos y comas.\n\n``` {python}\nbtc = btc.sort_values(by='Date')\nbtc = btc.reset_index(drop = True)\n\nbtc.info()\n```\n\n``` {python}\nbtc.describe()\n```\n\nEl resumen estadístico revela que el precio promedio de Bitcoin ha sido de aproximadamente 10,812.28 dólares, con un precio de apertura promedio cercano de 10,798.90 dólares. A lo largo del tiempo, los precios diarios más altos han promediado 11,067.45 dólares, mientras que los precios más bajos se han situado en 10,511.89 dólares, indicando una volatilidad diaria moderada. El volumen promedio de transacciones ha sido de 12.38 millones, mostrando un mercado activo, aunque con periodos de bajo volumen mínimo de 80 unidades. El cambio porcentual promedio ha sido positivo, de 0.42% por día, pero con episodios de alta volatilidad que incluyen caídas de hasta -57.21%. Además, los precios han sido significativamente bajos en el primer cuartil, con un valor de 226.70 dólares, lo que indica que durante un cuarto del tiempo analizado, el precio de Bitcoin se mantuvo muy por debajo de los niveles actuales.\n\n# Datos faltantes\n\nEl análisis de los datos faltantes en el conjunto de datos de Bitcoin muestra que la columna Volumen presenta valores nulos, que representan un pequeño porcentaje del total de registros. Para manejar estos datos faltantes, se ha implementado una imputación utilizando el algoritmo KNNImputer con 5 vecinos. Este enfoque permite estimar los valores faltantes en función de los patrones observados en los datos circundantes, lo cual es efectivo para mantener la coherencia y calidad de la información antes de proceder con el análisis de series de tiempo.\n\n``` {python}\nmissing_values = btc.isnull().sum()\nmissing_percentage = round((missing_values / len(btc)) * 100, 4)\nmissing_percentage\n```\n\nLa columna `Vol.` presenta un 0.12% de datos faltantes, lo cual es un porcentaje bajo pero significativo para los análisis.\n\nPara completar los valores faltantes en la columna de Volumen, se emplea el algoritmo de imputación KNNImputer, que utiliza la información de los vecinos más cercanos para predecir los valores faltantes.\n\n``` {python}\nimputer = KNNImputer(n_neighbors = 5)\n\nbtc[['Vol.']] = imputer.fit_transform(btc[['Vol.']])\n\nbtc.head()\n```\n\n# Visualización de precio y volumen tradeado\n\n``` {python}\n#| output: false\nfig = go.Figure(\n    data = [\n        go.Candlestick(\n            x = btc['Date'],\n            open = btc['Open'],\n            high = btc['High'],\n            low = btc['Low'],\n            close = btc['Price'],\n            name = 'Precio Bitcoin'\n        )\n    ]\n)\n\nfig.update_layout(\n    title='Gráfico de Velas de Bitcoin',\n    xaxis_title='Fecha',\n    yaxis_title='Precio (USD)',\n    hovermode='x',\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 40},\n    xaxis={'gridcolor': '#222', 'tickfont': {'color': 'white'}},\n    yaxis={'gridcolor': '#222', 'tickfont': {'color': 'white'}},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis_rangeslider_visible=False,\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/candlestick_price.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/candlestick_price.html'\n    width = '730'\n    height = '400'\n    title = 'Candlestick de la serie de tiempo del precio'\n>\n</iframe>\n```\n\nEn el gráfico de velas del Bitcoin se puede observar la evolución del precio de esta criptomoneda a lo largo del tiempo, abarcando desde sus primeros días hasta el año 2024. El gráfico revela períodos de alta volatilidad, con importantes picos en los años 2017-2018 y 2020-2022, en los cuales se registraron máximos históricos seguidos de caídas rápidas. Estos movimientos bruscos sugieren una naturaleza especulativa y altamente volátil en el mercado de Bitcoin. En el periodo más reciente (2023-2024), se evidencia un nuevo máximo cercano a los 70,000 USD, acompañado de correcciones pronunciadas, lo que indica una posible consolidación con fluctuaciones significativas. \n\n``` {python}\n#| output: false\nfig = go.Figure()\n\nfig.add_trace(\n    go.Histogram(\n        x = btc['Date'],\n        y = btc['Vol.'],\n        name = 'Volumen',\n        histfunc = 'sum'\n    )\n)\n\nfig.update_layout(\n    title='Histograma de Volumen Tradeado Diario',\n    xaxis_title='Fecha',\n    yaxis_title='Volumen tradeado',\n    bargap=0.1,\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 40},\n    xaxis={'gridcolor': '#222', 'tickfont': {'color': 'white'}},\n    yaxis={'gridcolor': '#222', 'tickfont': {'color': 'white'}},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/histogram_vol.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/histogram_vol.html'\n    width = '730'\n    height = '400'\n    title = 'Histograma del volumen de tradeado'\n>\n</iframe>\n```\n\nEn el histograma del volumen tradeado diario de Bitcoin se puede observar un patrón particular en la actividad de trading a lo largo del tiempo. La gráfica muestra un aumento abrupto y masivo del volumen tradeado en un periodo específico, alrededor del año 2022. Esto sugiere que durante este período hubo un incremento significativo en la cantidad de Bitcoin intercambiado, superando los 60 mil millones de unidades. Antes de este aumento, el volumen diario se mantuvo relativamente bajo y estable, lo que indica que la mayoría de la actividad de trading se concentró en los años más recientes. Este comportamiento puede estar relacionado con un mayor interés de inversores, la adopción generalizada de Bitcoin o la participación de grandes actores del mercado, provocando así picos de actividad inusuales. La presencia de este único pico elevado en la gráfica sugiere un cambio estructural en el mercado, lo cual es crucial para tener en cuenta en los análisis posteriores y en la modelización de la serie temporal.\n\n# Visualización semanal, mensual y anual del precio del bitcoin\n\n``` {python}\nbtc_c = btc.copy()\nbtc_c.set_index('Date', inplace = True)\n\nweekly_btc = btc_c.resample('W').mean()\nmonthly_btc = btc_c.resample('M').mean()\nyearly_btc = btc_c.resample('Y').mean()\n```\n\n``` {python}\n#| output: false\nfig_ts = make_subplots(\n    rows=3, cols=1, \n    shared_xaxes=True, \n    subplot_titles=(\n        'Precio Promedio Semanal',\n        'Precio Promedio Mensual',\n        'Precio Promedio Anual'\n    )\n)\n\nfig_ts.add_trace(\n    go.Scatter(\n        x=weekly_btc.index, \n        y=weekly_btc['Price'], \n        mode='lines+markers', \n        name='Precio Semanal'\n    ), \n    row=1, col=1\n)\n\nfig_ts.add_trace(\n    go.Scatter(\n        x=monthly_btc.index, \n        y=monthly_btc['Price'], \n        mode='lines+markers', \n        name='Precio Mensual'\n    ), \n    row=2, col=1\n)\n\nfig_ts.add_trace(\n    go.Scatter(\n        x=yearly_btc.index, \n        y=yearly_btc['Price'], \n        mode='lines+markers', \n        name='Precio Anual'\n    ), \n    row=3, col=1\n)\n\nfig_ts.update_layout(\n    title='Series de Tiempo Agrupadas (Semana, Mes, Año)',\n    xaxis_title='Fecha',\n    yaxis_title='Precio (USD)',\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    hovermode = 'x unified',\n    showlegend = False\n)\n\nfig_ts.show()\n```\n\n``` {python}\n#| echo: false\nfig_ts.write_html('graphs/ts_variety.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/ts_variety.html'\n    width = '700'\n    height = '800'\n    title = 'Series de Tiempo Agrupadas (Semana, Mes, Año)'\n>\n</iframe>\n```\n\nEn las series de tiempo agrupadas por semana, mes y año, se observa la evolución del precio promedio de Bitcoin con diferentes niveles de agregación. El gráfico semanal revela fluctuaciones cortas y alta volatilidad, mientras que el mensual suaviza estos movimientos, destacando picos en 2017-2018 y 2020-2022, reflejando ciclos de auge y caída. Por último, el gráfico anual muestra un crecimiento sostenido desde 2017, con un notable aumento en 2021 y una estabilización posterior hasta un nuevo máximo en 2024. Esta combinación permite analizar tanto la volatilidad a corto plazo como las tendencias a largo plazo.\n\n``` {python}\nbtc_c['Week'] = btc_c.index.to_series().dt.isocalendar().week\nbtc_c['Month'] = btc_c.index.to_series().dt.month\nbtc_c['Year'] = btc_c.index.to_series().dt.year\n```\n\n``` {python}\n#| output: false\ndef get_box(df: pd.DataFrame, X: str, Y: str, TITLE: str):\n    fig = px.box(\n        df,\n        x = X,\n        y = Y,\n        title = TITLE\n    )\n\n    fig.update_layout(\n        margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n        plot_bgcolor='rgba(0, 0, 0, 0.0)',\n        paper_bgcolor='rgba(0, 0, 0, 0.0)',\n        font_color=\"white\",\n        hoverlabel=dict(\n            bgcolor=\"#222\"\n        ),\n        xaxis=dict(gridcolor='#222', tickfont=dict(color='white'), title = 'Semana'),\n        yaxis=dict(gridcolor='#222', tickfont=dict(color='white'), title = 'Precio')\n    )\n\n    return fig\n\nfig_box_w = get_box(btc_c, 'Week', 'Price', 'Distribución semanal')\nfig_box_m = get_box(btc_c, 'Month', 'Price', 'Distribución mensual')\nfig_box_y = get_box(btc_c, 'Year', 'Price', 'Distribución anual')\n\nfig_box_w.show()\nfig_box_m.show()\nfig_box_y.show()\n```\n\n``` {python}\n#| echo: false\nfig_box_w.write_html('graphs/box_variety_w.html')\nfig_box_m.write_html('graphs/box_variety_m.html')\nfig_box_y.write_html('graphs/box_variety_y.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/box_variety_w.html'\n    width = '730'\n    height = '400'\n    title = 'Series de Tiempo Agrupadas (Semana, Mes, Año)'\n>\n</iframe>\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/box_variety_m.html'\n    width = '730'\n    height = '400'\n    title = 'Series de Tiempo Agrupadas (Semana, Mes, Año)'\n>\n</iframe>\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/box_variety_y.html'\n    width = '730'\n    height = '400'\n    title = 'Series de Tiempo Agrupadas (Semana, Mes, Año)'\n>\n</iframe>\n```\n\nEn los gráficos de distribución semanal, mensual y anual del precio de Bitcoin, se observa la variabilidad y dispersión del precio en diferentes escalas de tiempo. En la distribución semanal, los boxplots reflejan una amplia variabilidad, con picos notables en algunas semanas donde el precio superó los 60,000 USD, lo que sugiere fluctuaciones significativas en cortos periodos. En la distribución mensual, los rangos son más amplios, y se observan outliers frecuentes que destacan eventos extremos en cada mes, especialmente en los primeros y últimos meses del año. Por último, la distribución anual muestra una tendencia de expansión del rango de precios a medida que avanza el tiempo, con un crecimiento constante y variabilidad creciente desde 2016, alcanzando picos de precio más elevados en 2021 y 2024.\n\n# Validación de estacionariedad de la serie de tiempo\n\n``` {python}\n#| output: false\nlag_acf = acf(btc_c['Price'], nlags=2000)\n\nfig = go.Figure()\n\nfig.add_trace(go.Bar(\n    x=list(range(len(lag_acf))),\n    y=lag_acf,\n    marker_color='blue'\n))\n\nfig.update_layout(\n    title='Autocorrelación',\n    xaxis_title='Lags',\n    yaxis_title='Autocorrelación',\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis=dict(gridcolor='#222', tickfont=dict(color='white'))\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/acf_1.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/acf_1.html'\n    width = '730'\n    height = '400'\n    title = 'ACF de las diferencias estacionales'\n>\n</iframe>\n```\n\nEn el gráfico de autocorrelación, se representa la correlación de la serie temporal del precio de Bitcoin consigo misma en diferentes retardos (lags). La autocorrelación inicial es cercana a 1, lo cual indica que los valores consecutivos del precio están altamente correlacionados, es decir, existe una fuerte dependencia entre observaciones adyacentes. A medida que aumenta el número de retardos, la autocorrelación disminuye gradualmente hasta acercarse a cero, lo que sugiere que las observaciones distantes en el tiempo tienen poca o ninguna relación entre sí.\n\nEsta tendencia de decaimiento lento es una señal de que la serie no es estacionaria, ya que la autocorrelación no converge rápidamente hacia cero. La no estacionariedad implica que hay patrones como tendencias o ciclos que persisten en el tiempo, lo cual es importante tener en cuenta para modelar adecuadamente esta serie y elegir métodos de transformación que permitan hacerla estacionaria para aplicar modelos que asumen esta propiedad.\n\n## Prueba de estacionariedad de Ljung-Box\n\n``` {python}\nresult = acorr_ljungbox(btc_c['Price'], lags=[200, 500, 1000, 2000], return_df=True)\n\nif (result['lb_pvalue'] < 0.05).any():\n    print(\"La serie no es estacionaria (rechazamos la hipótesis nula para algunos lags).\")\nelse:\n    print(\"La serie es estacionaria (no se rechaza la hipótesis nula para los lags evaluados).\")\n\nresult\n```\n\n## Prueba de estacionariedad de Dickey Fuller\n\n``` {python}\nresult = adfuller(btc_c['Price'])\n\nprint(f'Estadístico de prueba: {result[0]}')\nprint(f'Valor p: {result[1]}\\n')\n\nif result[1] < 0.05:\n    print(\"La serie es estacionaria (rechazamos la hipótesis nula).\")\nelse:\n    print(\"La serie no es estacionaria (no se rechaza la hipótesis nula).\")\n```\n\n## Transformaciones para obtener una serie estacionaria\n\nPara obtener una serie estacionaria y facilitar el análisis y modelado de los precios de Bitcoin, se procederá a realizar una transformación basada en la diferenciación. La serie original ha mostrado indicios de no ser estacionaria, con un decaimiento lento en la autocorrelación, lo cual sugiere la presencia de tendencia. Por esta razón, se aplicará la diferenciación, que consiste en restar a cada valor su valor previo, con el objetivo de eliminar tendencias y estabilizar la media de la serie. Posteriormente, se evaluará la estacionariedad de la serie diferenciada mediante la prueba de Dickey-Fuller Aumentada (ADF), observando si el valor p es menor a 0.05, lo que indicaría que la serie ya es estacionaria.\n\n``` {python}\nbtc_d = btc_c.copy()\nbtc_d['Price'] = btc_c['Price'].diff()\n\nbtc_d\n```\n\n``` {python}\nresult_diff = adfuller(btc_d['Price'].dropna())\nprint(f'Estadístico de prueba: {result_diff[0]}')\nprint(f'Valor p: {result_diff[1]}\\n')\n\nif result_diff[1] < 0.05:\n    print(\"La serie diferenciada es estacionaria (rechazamos la hipótesis nula).\")\nelse:\n    print(\"La serie diferenciada no es estacionaria (no se rechaza la hipótesis nula).\")\n```\n\n# Comportamiento por agrupaciones de la serie de tiempo\n\nPara explorar más a fondo el comportamiento de la serie diferenciada, se realizará un análisis por períodos, agrupando los datos a nivel diario, semanal y mensual para calcular la media y la desviación estándar de los precios en cada intervalo. Esto permitirá identificar patrones de variabilidad en diferentes escalas temporales. También se calcularán medias y desviaciones estándar móviles para ventanas de 7, 30 y 90 días, lo que ayudará a observar cómo evolucionan el promedio y la dispersión de los precios a lo largo del tiempo.\n\n``` {python}\nweekly = btc_d['Price'].resample('W').agg(['mean', 'std'])\ndaily = btc_d['Price'].resample('D').agg(['mean', 'std'])\nmonthly = btc_d['Price'].resample('M').agg(['mean', 'std'])\n```\n\n``` {python}\nbtc_d['mu_7'] = btc_d['Price'].rolling(window = 7).mean()\nbtc_d['std_7'] = btc_d['Price'].rolling(window = 7).std()\n\nbtc_d['mu_30'] = btc_d['Price'].rolling(window = 30).mean()\nbtc_d['std_30'] = btc_d['Price'].rolling(window = 30).std()\n\nbtc_d['mu_90'] = btc_d['Price'].rolling(window = 90).mean()\nbtc_d['std_90'] = btc_d['Price'].rolling(window = 90).std()\n\nbtc_d\n```\n\n``` {python}\n#| output: false\ndef get_hist(df: pd.DataFrame, diff_: int, title: str):\n    fig = px.histogram(\n        df['Price'].diff(diff_).dropna(),\n        nbins = 30,\n        title = title\n    )\n\n    fig.update_layout(\n        margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n        plot_bgcolor='rgba(0, 0, 0, 0.0)',\n        paper_bgcolor='rgba(0, 0, 0, 0.0)',\n        font_color=\"white\",\n        hoverlabel=dict(\n            bgcolor=\"#222\"\n        ),\n        xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n        yaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n        showlegend = False\n    )\n\n    return fig\n\nfig_7 = get_hist(btc_d, 7, 'Distribución con lag = 7')\nfig_30 = get_hist(btc_d, 30, 'Distribución con lag = 30')\nfig_90 = get_hist(btc_d, 90, 'Distribución con lag = 90')\n\nfig_7.show()\nfig_30.show()\nfig_90.show()\n```\n\n``` {python}\n#| echo: false\nfig_7.write_html('graphs/hist_7.html')\nfig_30.write_html('graphs/hist_30.html')\nfig_90.write_html('graphs/hist_90.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/hist_7.html'\n    width = '730'\n    height = '400'\n    title = 'Distribución con lag = 7'\n>\n</iframe>\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/hist_30.html'\n    width = '730'\n    height = '400'\n    title = 'Distribución con lag = 30'\n>\n</iframe>\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/hist_90.html'\n    width = '730'\n    height = '400'\n    title = 'Distribución con lag = 90'\n>\n</iframe>\n```\n\nEn los histogramas de las distribuciones con diferentes retardos (lags) de 7, 30 y 90 días, se puede observar la variabilidad de los precios diferenciados del Bitcoin a lo largo del tiempo. En los tres gráficos, se nota una clara concentración de los valores alrededor de cero, indicando que la mayoría de las diferencias en los precios son relativamente pequeñas en cada lag evaluado.\n\nSin embargo, a medida que aumenta el lag de 7 a 30 y luego a 90 días, se aprecia un aumento gradual en la dispersión de los datos, lo cual se refleja en colas más extendidas en los histogramas. Este comportamiento indica que, conforme se incrementa el período de comparación, las diferencias de precio tienden a ser más amplias, sugiriendo una mayor variabilidad en el largo plazo.\n\n# Medias móviles y tendencia\n\n``` {python}\n#| output: false\nbtc_d = btc_d.fillna(0)\n\nMA2 = btc_d['Price'].rolling(window = 2).mean()\nTwoXMA2 = MA2.rolling(window=2).mean()\n\nMA4 = btc_d['Price'].rolling(window = 4).mean()\nTwoXMA4 = MA4.rolling(window=2).mean()\n\nMA3 = btc_d['Price'].rolling(window = 3).mean()\nThreeXMA3 = MA3.rolling(window=3).mean()\n\nfig = make_subplots(\n    rows=3, cols=1, \n    shared_xaxes=True, \n    subplot_titles=(\"2 day MA & 2X2 day MA\", \"4 day MA & 2X4 day MA\", \"3 day MA & 3X3 day MA\")\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=btc_d['Price'].iloc[:45], \n        mode='lines', \n        name='Close Price', \n        line=dict(color='#9B7EBD')\n    ), \n    row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=MA2.iloc[:45], \n        mode='lines', \n        name='2 day MA', \n        line=dict(color='#7AB2D3', dash='dash')\n    ), \n    row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=TwoXMA2.iloc[:45], \n        mode='lines', \n        name='2X2 day MA', \n        line=dict(color='#CBD2A4', dash='dash')\n    ), \n    row=1, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=btc_d['Price'].iloc[:45], \n        mode='lines', \n        name='Close Price', \n        showlegend=False, \n        line=dict(color='#9B7EBD')\n    ), \n    row=2, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=MA4.iloc[:45], \n        mode='lines', \n        name='4 day MA', \n        line=dict(color='#7AB2D3', dash='dash')\n    ), \n    row=2, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=TwoXMA4.iloc[:45], \n        mode='lines', \n        name='2X4 day MA', \n        line=dict(color='#CBD2A4', dash='dash')\n    ), \n    row=2, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=btc_d['Price'].iloc[:45], \n        mode='lines', \n        name='Close Price', \n        showlegend=False, \n        line=dict(color='#9B7EBD')\n    ), \n    row=3, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=MA3.iloc[:45], \n        mode='lines', \n        name='3 day MA', \n        line=dict(color='#7AB2D3', dash='dash')\n    ), \n    row=3, col=1\n)\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index[:45], \n        y=ThreeXMA3.iloc[:45], \n        mode='lines', \n        name='3X3 day MA', \n        line=dict(color='#CBD2A4', dash='dash')\n    ), \n    row=3, col=1\n)\n\nfig.update_layout(\n    title='',\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    yaxis=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    xaxis2=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    yaxis2=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    xaxis3=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    yaxis3=dict(\n        gridcolor='#222', \n        tickfont=dict(color='white')\n    ),\n    hovermode='x unified',\n    showlegend=False\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/media_movil.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/media_movil.html'\n    width = '730'\n    height = '800'\n    title = 'Distribución con lag = 7'\n>\n</iframe>\n```\n\nLos gráficos muestran la evolución de los precios diferenciados de Bitcoin utilizando medias móviles (2, 3 y 4 días) y sus versiones suavizadas (2X y 3X). Las medias móviles siguen de cerca las fluctuaciones a corto plazo, mientras que las medias dobles suavizan las curvas, destacando tendencias más claras y menos influenciadas por variaciones bruscas. Las curvas suavizadas permiten identificar patrones subyacentes y direcciones generales, eliminando parte del ruido presente en los datos diarios. Esto facilita la visualización de la evolución de los precios en diferentes escalas temporales.\n\nLa descomposición de la serie de tiempo se realiza para identificar y separar sus componentes clave: tendencia, estacionalidad y residuales, lo que facilita el análisis y el modelado.\n\n``` {python}\n#| output: false\ndecomposition = seasonal_decompose(\n    btc_d['Price'], \n    model='additive', \n    period=180\n)\n\nfig = make_subplots(\n    rows=4, cols=1, \n    shared_xaxes=True, \n    subplot_titles=(\"Observado\", \"Tendencia\", \"Estacionalidad\", \"Residual\")\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index, \n        y=btc_d['Price'], \n        mode='lines', \n        name='Observado', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=1, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index, \n        y=decomposition.trend, \n        mode='lines', \n        name='Tendencia', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=2, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index, \n        y=decomposition.seasonal, \n        mode='lines', \n        name='Estacionalidad', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=3, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_d.index, \n        y=decomposition.resid, \n        mode='lines', \n        name='Residual', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=4, col=1\n)\n\nfig.update_layout(\n    title_text=\"Descomposición Estacional de la Serie de Tiempo\", \n    showlegend=False,\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis4=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis4=dict(gridcolor='#222', tickfont=dict(color='white')),\n    hovermode = 'x unified',\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/descomposition.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/descomposition.html'\n    width = '730'\n    height = '800'\n    title = 'Distribución con lag = 7'\n>\n</iframe>\n```\n\nLa serie observada muestra una mayor volatilidad en los últimos años. La tendencia revela un comportamiento de largo plazo, destacando caídas y recuperaciones. La estacionalidad presenta patrones cíclicos repetitivos, indicando un componente periódico constante en la serie. Finalmente, los residuales capturan las variaciones no explicadas, mostrando un aumento de la fluctuación aleatoria en el periodo reciente. Esta separación es crucial para comprender mejor la dinámica del precio del Bitcoin.\n\nAhora, se ajusta el precio diferenciado de Bitcoin restando la media móvil doble de 4 días (TwoXMA4) para eliminar el componente de tendencia y suavizar las fluctuaciones de corto plazo. Este ajuste ayuda a centrarse en los cambios más significativos y reduce la influencia de la variabilidad corta. Al realizar esta transformación, se obtiene una serie que resalta las desviaciones del comportamiento promedio reciente, facilitando la identificación de patrones o anomalías.\n\n``` {python}\nbtc_ma = btc_d.copy()\n\nbtc_ma['Price_adj'] = btc_ma['Price'] - TwoXMA4\nbtc_ma = btc_ma.fillna(0)\n```\n\n``` {python}\n#| output: false\ndecomposition = seasonal_decompose(\n    btc_ma['Price_adj'], \n    model='additive', \n    period=180\n)\n\nfig = make_subplots(\n    rows=4, cols=1, \n    shared_xaxes=True, \n    subplot_titles=(\"Observado\", \"Tendencia\", \"Estacionalidad\", \"Residual\")\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_ma.index, \n        y=btc_ma['Price_adj'], \n        mode='lines', \n        name='Observado', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=1, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_ma.index, \n        y=decomposition.trend, \n        mode='lines', \n        name='Tendencia', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=2, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_ma.index, \n        y=decomposition.seasonal, \n        mode='lines', \n        name='Estacionalidad', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=3, col=1\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=btc_ma.index, \n        y=decomposition.resid, \n        mode='lines', \n        name='Residual', \n        line=dict(color='#9B7EBD', width=2)\n    ),\n    row=4, col=1\n)\n\nfig.update_layout(\n    title_text=\"Descomposición Estacional de la Serie de Tiempo\", \n    showlegend=False,\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis2=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis3=dict(gridcolor='#222', tickfont=dict(color='white')),\n    xaxis4=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis4=dict(gridcolor='#222', tickfont=dict(color='white')),\n    hovermode = 'x unified',\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/descomposition_2.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/descomposition_2.html'\n    width = '730'\n    height = '800'\n    title = 'Distribución con lag = 7'\n>\n</iframe>\n```\n\nSe observa que la tendencia se ha aplanado considerablemente, lo que indica que las oscilaciones de corto plazo fueron removidas. La estacionalidad se mantiene, evidenciando ciclos recurrentes y patrones que persisten en la serie. Los residuales ahora capturan mejor las fluctuaciones no explicadas, lo cual puede indicar la presencia de variabilidad no sistemática o ruido en los datos. En conjunto, esta transformación permite aislar los patrones relevantes y eliminar las influencias de corto plazo, proporcionando una base más clara para el análisis de la serie de tiempo.\n\nAhora, verificaremos si nuestra serie de tiempo se mantiene siendo estacionaria o no.\n\n## Prueba de estacionariedad de Ljung-Box\n\n``` {python}\nresult = acorr_ljungbox(btc_ma['Price_adj'], lags=[24, 100, 200], return_df=True)\n\nif (result['lb_pvalue'] < 0.05).any():\n    print(\"La serie no es estacionaria (rechazamos la hipótesis nula para algunos lags).\")\nelse:\n    print(\"La serie es estacionaria (no se rechaza la hipótesis nula para los lags evaluados).\")\n\nresult\n```\n\n## Prueba de estacionariedad de Dickey Fuller\n\n``` {python}\nresult = adfuller(btc_ma['Price_adj'])\n\nprint(f'Estadístico de prueba: {result[0]}')\nprint(f'Valor p: {result[1]}\\n')\n\nif result[1] < 0.05:\n    print(\"La serie es estacionaria (rechazamos la hipótesis nula).\")\nelse:\n    print(\"La serie no es estacionaria (no se rechaza la hipótesis nula).\")\n```\n\n``` {python}\n#| output: false\nlag_acf = acf(btc_ma['Price_adj'], nlags=100)\n\nfig = go.Figure()\n\nfig.add_trace(go.Bar(\n    x=list(range(len(lag_acf))),\n    y=lag_acf,\n    marker_color='blue'\n))\n\nfig.update_layout(\n    title='Autocorrelación',\n    xaxis_title='Lags',\n    yaxis_title='Autocorrelación',\n    margin={'b': 0, 'r': 30, 'l': 30, 't': 80},\n    plot_bgcolor='rgba(0, 0, 0, 0.0)',\n    paper_bgcolor='rgba(0, 0, 0, 0.0)',\n    font_color=\"white\",\n    hoverlabel=dict(\n        bgcolor=\"#222\"\n    ),\n    xaxis=dict(gridcolor='#222', tickfont=dict(color='white')),\n    yaxis=dict(gridcolor='#222', tickfont=dict(color='white'))\n)\n\nfig.show()\n```\n\n``` {python}\n#| echo: false\nfig.write_html('graphs/acf_2.html')\n```\n\n``` {=html}\n<iframe\n    src = 'graphs/acf_2.html'\n    width = '730'\n    height = '400'\n    title = 'ACF de las diferencias estacionales'\n>\n</iframe>\n```\n\n# Retorno acumulado diario y volatilidad \n\n``` {python}\nbtc['R_j'] = (btc['Price'] - btc['Price'].shift(1)) / btc['Price'].shift(1)\nbtc['R_j'].fillna(0, inplace=True)\n\nbtc['A_t'] = btc['R_j'].cumsum()\n\ndef calc_volt(btc: pd.DataFrame, window: int):\n    return btc['R_j'].rolling(window = window).std()\n\nws = [7, 14, 21, 28]\nfor w in ws:\n    btc[f'σ_{w}'] = calc_volt(btc, w)\n\nbtc\n```\n\n``` {python}\nbtc.to_csv('data/btc_models.csv', index = False)\n```"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","include-in-header":[{"text":"<link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"icon/apple-icon-180x180.png\">\n<link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"icon/favicon-32x32.png\">\n<link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"icon/favicon-16x16.png\">\n<link rel=\"mask-icon\" href=\"icon/safari-pinned-tab.svg\" color=\"#5bbad5\">\n<meta name=\"msapplication-TileColor\" content=\"#da532c\">\n<meta name=\"theme-color\" content=\"#ffffff\">\n"}],"toc":true,"toc-depth":5,"css":["styles.css"],"output-file":"eda.html"},"language":{"toc-title-document":"Tabla de contenidos","toc-title-website":"En esta página","related-formats-title":"Otros formatos","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Fuente","other-links-title":"Otros Enlaces","code-links-title":"Enlaces de código","launch-dev-container-title":"Iniciar Dev Container","launch-binder-title":"Iniciar Binder","article-notebook-label":"Cuaderno de Artículo","notebook-preview-download":"Descargar Cuaderno","notebook-preview-download-src":"Descargar código fuente","notebook-preview-back":"Volver al Artículo","manuscript-meca-bundle":"Archivo MECA","section-title-abstract":"Resumen","section-title-appendices":"Apéndices","section-title-footnotes":"Notas","section-title-references":"Referencias","section-title-reuse":"Reutilización","section-title-copyright":"Derechos de autor","section-title-citation":"Cómo citar","appendix-attribution-cite-as":"Por favor, cita este trabajo como:","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Ver Licencia","title-block-author-single":"Autor/a","title-block-author-plural":"Autores/as","title-block-affiliation-single":"Afiliación","title-block-affiliation-plural":"Afiliaciones","title-block-published":"Fecha de publicación","title-block-modified":"Fecha de modificación","title-block-keywords":"Palabras clave","callout-tip-title":"Tip","callout-note-title":"Nota","callout-warning-title":"Advertencia","callout-important-title":"Importante","callout-caution-title":"Precaución","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar todo el código","code-tools-hide-all-code":"Ocultar todo el código","code-tools-view-source":"Ver el código fuente","code-tools-source-code":"Ejecutar el código","tools-share":"Compartir","tools-download":"Descargar","code-line":"Línea","code-lines":"Líneas","copy-button-tooltip":"Copiar al portapapeles","copy-button-tooltip-success":"Copiado","repo-action-links-edit":"Editar esta página","repo-action-links-source":"Ver el código","repo-action-links-issue":"Informar de un problema","back-to-top":"Volver arriba","search-no-results-text":"Sin resultados","search-matching-documents-text":"documentos encontrados","search-copy-link-title":"Copiar el enlace en la búsqueda","search-hide-matches-text":"Ocultar resultados adicionales","search-more-match-text":"resultado adicional en este documento","search-more-matches-text":"resultados adicionales en este documento","search-clear-button-title":"Borrar","search-text-placeholder":"","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Enviar","search-label":"Buscar","toggle-section":"Alternar sección","toggle-sidebar":"Alternar barra lateral","toggle-dark-mode":"Alternar modo oscuro","toggle-reader-mode":"Alternar modo lector","toggle-navigation":"Navegación de palanca","crossref-fig-title":"Figura","crossref-tbl-title":"Tabla","crossref-lst-title":"Listado","crossref-thm-title":"Teorema","crossref-lem-title":"Lema","crossref-cor-title":"Corolario","crossref-prp-title":"Proposición","crossref-cnj-title":"Conjetura","crossref-def-title":"Definición","crossref-exm-title":"Ejemplo","crossref-exr-title":"Ejercicio","crossref-ch-prefix":"Capítulo","crossref-apx-prefix":"Apéndice","crossref-sec-prefix":"Sección","crossref-eq-prefix":"Ecuación","crossref-lof-title":"Listado de Figuras","crossref-lot-title":"Listado de Tablas","crossref-lol-title":"Listado de Listados","environment-proof-title":"Prueba","environment-remark-title":"Observación","environment-solution-title":"Solución","listing-page-order-by":"Ordenar por","listing-page-order-by-default":"Por defecto","listing-page-order-by-date-asc":"Menos reciente","listing-page-order-by-date-desc":"Más reciente","listing-page-order-by-number-desc":"De mayor a menor","listing-page-order-by-number-asc":"De menor a mayor","listing-page-field-date":"Fecha","listing-page-field-title":"Título","listing-page-field-description":"Descripción","listing-page-field-author":"Autor/a","listing-page-field-filename":"Nombre de archivo","listing-page-field-filemodified":"Fecha de modificación","listing-page-field-subtitle":"Subtítulo","listing-page-field-readingtime":"Tiempo de lectura","listing-page-field-wordcount":"Conteo de Palabras","listing-page-field-categories":"Categorías","listing-page-minutes-compact":"{0} minutos","listing-page-category-all":"Todas","listing-page-no-matches":"No hay resultados","listing-page-words":"{0} palabras","listing-page-filter":"Filtro","draft":"Borrador"},"metadata":{"lang":"es","fig-responsive":true,"quarto-version":"1.5.57","author":[{"name":"Jorge Borja","url":"https://www.linkedin.com/in/jorgeborjas25/","degrees":["Mag"],"affiliation":[{"id":"uninorte","name":"Universidad del Norte","department":"Matemáticas y Estadísticas","url":"https://uninorte.edu.co/"}]},{"name":"Gabriela Díaz Porto","url":"https://www.linkedin.com/in/gabriela-diaz-porto-6a0729201","degrees":["Mag"]}],"bibliography":["references.bib"],"jupyter":"pt_ts","theme":"cyborg","smooth-scroll":true,"toc-title":"En esta página","title":"Análisis exploratorio de los datos"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}